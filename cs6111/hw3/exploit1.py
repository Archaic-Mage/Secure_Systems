from pwn import *
import json
import time
import sys
import os
from Crypto.Cipher import AES

# %%
key = b'5\xec\x80\xac\xd6\xab\x17/\x0f.P3\xdb<8\xd0'

# %%
def pad(s):
  return s + bytes((16 - len(s) % 16) * chr(16 - len(s) % 16), 'ascii')

# %%
def isvalidpad(s):
    value = ord(chr(s[-1]))*s[-1:]==s[-ord(chr(s[-1])):]
    return value  

# %%
def unpad(s):
    value = s[:-ord(s[len(s)-1:])]
    return value

# %%
def decrypt(m):
    cipher = AES.new(bytes.fromhex(key.hex()), AES.MODE_CBC, bytes.fromhex(m[0:32]))
    return cipher.decrypt(bytes.fromhex(m[32:]))

blocksize = 16

plaintext = {"roll": "CS20B068", "is_admin": "true", "expires": "2024-12-02"} 

def pad(s):
    return s + bytes((16 - len(s) % 16) * chr(16 - len(s) % 16), 'ascii')

def xor(x1,padlength,flag=0):
    paddingIndex = blocksize - padlength
    for i in range(paddingIndex+1,blocksize):
        x1[i] ^= (padlength-flag)
    return x1

def check(ct, c2, i, paddingIndex):
    ct[paddingIndex] = i
    # p = process(["python", "cookie.py"])
    p = remote("10.21.236.75", 8082)
    try:
        p.recvuntil("What is your cookie?")
        c = (bytes(ct) + bytes(c2)).hex()
        p.sendline(c)
        out = p.recvline()
        print("trying for: " + str(paddingIndex) + ", " + str(i))
        # cookie2decoded = decrypt(c)
        # if isvalidpad(cookie2decoded):
        #     # print(ct)
        #     return ct
        if b"invalid padding" not in out:
            p.close()
            return ct
        p.close()
        return None
    except:
        p.close()
        return check(ct,c2, i, paddingIndex)


def findDecTillPadlen(ct,padLength,c2):
    paddingIndex = blocksize - padLength  # need to change this index
    for i in range(0,256):
        t = check(ct, c2, i, paddingIndex)
        if t:
            ct = t
            return ct
        #iterate over all possible values of the byte at paddingIndex
#        ct[paddingIndex] = i
#        # p = process(["python", "cookie.py"])
#        p = remote("10.21.236.75", 8082)
#        try:
#            p.recvuntil("What is your cookie?")
#            c = (bytes(ct) + bytes(c2)).hex()
#            p.sendline(c)
#            out = p.recvline()
#            print("trying for: " + str(paddingIndex) + ", " + str(i))
#            # cookie2decoded = decrypt(c)
#            # if isvalidpad(cookie2decoded):
#            #     # print(ct)
#            #     return ct
#            if b"invalid padding" not in out:
#                p.close()
#                return ct
#            p.close()
#        except:
#            p.close()
#            return findDecTillPadlen(ct,padLength,c2)

def single_block_attack(pt, c2):
    IV = [0]*blocksize
    for padlength in range(1,blocksize+1):
        
        #xor pad value to all indices from pad in to get the proper padding of last 'padlength' bytes
        IV = xor(IV,padlength,0)
        IV = xor(IV,padlength,1)
        # we need to find the correct byte at padlength index from behind
        tempIV = findDecTillPadlen(IV,padlength,c2)
        IV = tempIV

    # find actual IV which will be the ciphertext for the previous block
    for j in range(blocksize):
        IV[j] = IV[j]^blocksize
        IV[j] = IV[j]^pt[j]

    return IV


def full_attack(pt):
    blocks = [pt[i:i+blocksize] for i in range(0, len(pt), blocksize)]
    result = b''
    c2 = os.urandom(blocksize)
    ciphertext = c2.hex()

    for ptb in reversed(blocks):
        dec = single_block_attack(ptb, c2)
        hex_dec = bytearray(dec).hex()
        # add this block behind the previous block
        ciphertext = hex_dec + ciphertext
        c2 = dec

    return ciphertext

def main():
    s = json.dumps(plaintext)
    actual_message = pad(s.encode())
    enc = full_attack(actual_message)
    print(enc) 
    # m = decrypt(enc)
    # if isvalidpad(m):
    #     print("valid")
    # else:
    #     print("invalid")
    p = remote("10.21.236.75", 8082)
    # p = process(["python", "cookie.py"])
    p.recvuntil("What is your cookie?")
    p.sendline(enc)
    p.interactive()
    # print(enc)

if __name__ =="__main__":
    main()

